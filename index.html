<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlusLab 3D Generator</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://esm.sh/three@0.160.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1",
                "uuid": "https://esm.sh/uuid@9.0.1"
            }
        }
    </script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; height: 100%; }
        canvas { touch-action: none; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #4B5563; }
        
        .glass-panel {
            background: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, useEffect, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { OrbitControls, Environment, PerspectiveCamera } from '@react-three/drei';

        // --- ICONS ---
        const Icon = ({ path, size = 14, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} dangerouslySetInnerHTML={{__html: path}} />
        );
        const Icons = {
            Box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/>',
            Grid: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/>',
            Move: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="15 19 12 22 9 19"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/>',
            Layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/>',
            Brush: '<path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/><path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2.5 2.24 0 .46.62.8.62.8"/><path d="M14.26 17.74c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2.5 2.24 0 .46.62.8.62.8"/>',
            Rotate: '<path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>',
            Download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/>'
        };

        // --- UI COMPONENTS ---
        
        const ControlGroup = ({ title, icon, children }) => (
            <div className="mb-4 border-b border-gray-700 pb-3 last:border-0">
                <div className="flex items-center gap-2 mb-3 text-xs font-bold text-gray-400 uppercase tracking-wider">
                    {icon && <Icon path={icon} className="text-blue-500" />}
                    {title}
                </div>
                <div className="space-y-3 px-1">{children}</div>
            </div>
        );

        const Slider = ({ label, value, min, max, step = 0.1, onChange }) => (
            <div className="flex flex-col gap-1">
                <div className="flex justify-between text-[10px] text-gray-400 font-mono">
                    <span>{label}</span>
                    <span className="text-blue-300">{typeof value === 'number' ? value.toFixed(2) : value}</span>
                </div>
                <input 
                    type="range" min={min} max={max} step={step} value={value} 
                    onChange={(e) => onChange(parseFloat(e.target.value))}
                    className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500 hover:accent-blue-400"
                />
            </div>
        );

        const ColorPicker = ({ label, value, onChange }) => (
            <div className="flex items-center justify-between text-[10px]">
                <span className="text-gray-400 font-mono">{label}</span>
                <div className="flex items-center gap-2">
                    <span className="font-mono text-gray-500">{value}</span>
                    <input type="color" value={value} onChange={(e) => onChange(e.target.value)} className="w-6 h-6 rounded cursor-pointer bg-transparent border-0 p-0" />
                </div>
            </div>
        );

        // --- 3D COMPONENTS ---

        // Pseudo Random Helper
        const pseudoRandom = (x, y) => {
            return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 - Math.floor(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453);
        };

        const PlusInstances = ({ config, paintingState, onHover, setHoveredInstance }) => {
            const meshRef = useRef();
            const { 
                gridCount, spacing, 
                size, thickness, extrudeDepth, 
                waveAmp, waveFreq, noiseAmp, 
                rowOffset, orientation,
                color1, color2, opacity 
            } = config;

            // 1. Generate Geometry (Extruded Plus)
            const geometry = useMemo(() => {
                const shape = new THREE.Shape();
                const s = size / 2;
                const t = thickness / 2;
                
                shape.moveTo(-t, -s);
                shape.lineTo(t, -s);
                shape.lineTo(t, -t);
                shape.lineTo(s, -t);
                shape.lineTo(s, t);
                shape.lineTo(t, t);
                shape.lineTo(t, s);
                shape.lineTo(-t, s);
                shape.lineTo(-t, t);
                shape.lineTo(-s, t);
                shape.lineTo(-s, -t);
                shape.lineTo(-t, -t);
                shape.closePath();

                const extrudeSettings = {
                    steps: 1,
                    depth: Math.max(0.1, extrudeDepth), // Prevent 0 depth
                    bevelEnabled: true,
                    bevelThickness: 0.5,
                    bevelSize: 0.5,
                    bevelSegments: 2
                };

                const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                // Center geometry
                geo.center();
                return geo;
            }, [size, thickness, extrudeDepth]);

            // 2. Material (Translucent G+D Style)
            // Using MeshPhysicalMaterial for glass-like feel
            const material = useMemo(() => new THREE.MeshPhysicalMaterial({
                color: new THREE.Color(color1),
                emissive: new THREE.Color(color2),
                emissiveIntensity: 0.2,
                metalness: 0.1,
                roughness: 0.2,
                transmission: 0.0, // Glass effect off for better performance with many objects, relying on opacity
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide,
                depthWrite: false, // Important for transparency overlap
                blending: THREE.AdditiveBlending // Glowy look
            }), [color1, color2, opacity]);

            // 3. Grid Calculation & Instance Update
            const tempObject = new THREE.Object3D();
            
            useFrame(({ clock }) => {
                if (!meshRef.current) return;

                const time = clock.getElapsedTime();
                const total = gridCount * gridCount;
                const centerOffset = (gridCount * spacing) / 2;

                let i = 0;
                for (let x = 0; x < gridCount; x++) {
                    for (let y = 0; y < gridCount; y++) {
                        const id = `${x}-${y}`;
                        
                        // Base Position
                        let posX = (x * spacing) - centerOffset;
                        let posY = (y * spacing) - centerOffset;
                        let posZ = 0;

                        // Row Offset (Rhythm)
                        if (y % 2 !== 0) posX += rowOffset;

                        // Wave (Z-Axis & Y-Axis movement)
                        const waveZ = Math.sin((x * 0.2) + (time * 0.5)) * waveAmp;
                        const waveY = Math.cos((y * 0.2) + (time * 0.5)) * waveAmp * 0.5;
                        
                        posZ += waveZ;
                        posY += waveY;

                        // Noise
                        const noise = pseudoRandom(x, y);
                        posZ += noise * noiseAmp;

                        tempObject.position.set(posX, posY, posZ);

                        // Orientation (Rotation)
                        tempObject.rotation.set(0, 0, 0); // Reset
                        if (orientation === 1) tempObject.rotation.x = Math.PI / 2; // Flat (Floor)
                        if (orientation === 2) tempObject.rotation.y = Math.PI / 2; // Side
                        // orientation 0 is Default (Face Camera)

                        // Scale (Base + Paint Modifications)
                        let scale = 1;
                        if (paintingState.modifications[id]) {
                            scale += paintingState.modifications[id];
                        }
                        scale = Math.max(0.1, scale);
                        tempObject.scale.set(scale, scale, scale);

                        tempObject.updateMatrix();
                        meshRef.current.setMatrixAt(i, tempObject.matrix);
                        
                        // Color variation per instance could go here using setColorAt
                        i++;
                    }
                }
                meshRef.current.instanceMatrix.needsUpdate = true;
            });

            // Handle Interaction
            const handlePointerMove = (e) => {
                if (paintingState.isPainting && paintingState.brushSize > 0) {
                   // Calculate grid index from instanceId
                   const instanceId = e.instanceId;
                   if (instanceId !== undefined) {
                       setHoveredInstance(instanceId);
                       onHover(instanceId);
                   }
                }
            };

            return (
                <instancedMesh 
                    ref={meshRef} 
                    args={[geometry, material, gridCount * gridCount]}
                    onPointerMove={handlePointerMove}
                    onPointerDown={handlePointerMove} // Also paint on click
                />
            );
        };

        const Scene = ({ config, paintingState, onPaint }) => {
            const [hoveredInstance, setHoveredInstance] = useState(null);

            // Logic to apply paint
            const handlePaint = (instanceIndex) => {
                 // Convert linear index back to grid coordinates (simple way, or just use index as key)
                 // Let's use x-y key for consistency with previous app, but index is faster here.
                 // Index is x * gridCount + y (inner loop is y) OR outer loop x? 
                 // In the loop above: x is outer, y is inner. i increments per y.
                 // So index = x * gridCount + y.
                 
                 const y = instanceIndex % config.gridCount;
                 const x = Math.floor(instanceIndex / config.gridCount);
                 const id = `${x}-${y}`;
                 
                 onPaint(id);
            };

            return (
                <>
                    <PerspectiveCamera makeDefault position={[0, 0, 100]} fov={50} />
                    <OrbitControls makeDefault enableDamping dampingFactor={0.1} />

                    {/* Lights matching G+D aesthetic */}
                    <ambientLight intensity={0.5} color="#001133" />
                    <directionalLight position={[50, 50, 50]} intensity={2} color="#4dc0ff" />
                    <pointLight position={[-50, -50, 50]} intensity={1} color="#ff00aa" />
                    <fog attach="fog" args={[config.bgColor, 50, 300]} />

                    <group>
                        <PlusInstances 
                            config={config} 
                            paintingState={paintingState} 
                            onHover={handlePaint} 
                            setHoveredInstance={setHoveredInstance}
                        />
                    </group>
                </>
            );
        };

        // --- MAIN APP ---

        function App() {
            // State
            const [gridCount, setGridCount] = useState(20);
            const [spacing, setSpacing] = useState(8);
            const [size, setSize] = useState(4);
            const [thickness, setThickness] = useState(1.2);
            const [extrudeDepth, setExtrudeDepth] = useState(10); // NEW: Extrusion
            const [orientation, setOrientation] = useState(0); // NEW: 0=Face, 1=Flat, 2=Side
            
            const [waveAmp, setWaveAmp] = useState(5);
            const [waveFreq, setWaveFreq] = useState(1);
            const [noiseAmp, setNoiseAmp] = useState(2);
            const [rowOffset, setRowOffset] = useState(0);

            const [color1, setColor1] = useState("#00b7ff");
            const [color2, setColor2] = useState("#003366");
            const [bgColor, setBgColor] = useState("#02040a");
            const [opacity, setOpacity] = useState(0.6);

            // Painting State
            const [isPainting, setIsPainting] = useState(false);
            const [brushTool, setBrushTool] = useState(1); // 1 = grow, -1 = shrink
            const [modifications, setModifications] = useState({});

            const handlePaint = (id) => {
                if (!isPainting) return;
                setModifications(prev => {
                    const current = prev[id] || 0;
                    return { ...prev, [id]: Math.min(3, Math.max(-0.9, current + (0.05 * brushTool))) };
                });
            };

            const resetMods = () => setModifications({});
            
            const handleExport = () => {
                const canvas = document.querySelector('canvas');
                if (canvas) {
                    const link = document.createElement('a');
                    link.download = 'pluslab-3d-render.png';
                    link.href = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
                    link.click();
                }
            };

            const config = {
                gridCount, spacing, size, thickness, extrudeDepth, 
                waveAmp, waveFreq, noiseAmp, rowOffset, orientation,
                color1, color2, bgColor, opacity
            };

            return (
                <div className="flex h-full text-white font-sans selection:bg-blue-500/30">
                    
                    {/* LEFT PANEL */}
                    <aside className="w-80 flex-shrink-0 glass-panel overflow-y-auto flex flex-col z-10 shadow-2xl">
                        <div className="p-4 border-b border-gray-700 bg-gray-900/50 sticky top-0 backdrop-blur-md z-20">
                            <h1 className="text-xl font-bold bg-gradient-to-r from-blue-400 to-cyan-300 bg-clip-text text-transparent">PlusLab 3D</h1>
                            <p className="text-[10px] text-gray-500 uppercase tracking-widest mt-1">Spatial Generator</p>
                        </div>

                        <div className="p-4 space-y-6">
                            
                            {/* GEOMETRIE */}
                            <ControlGroup title="Form & Extrusion" icon={Icons.Box}>
                                <Slider label="Größe (Arm)" value={size} min={1} max={10} onChange={setSize} />
                                <Slider label="Dicke" value={thickness} min={0.2} max={4} onChange={setThickness} />
                                <Slider label="Extrusion (Tiefe)" value={extrudeDepth} min={0.1} max={30} step={0.5} onChange={setExtrudeDepth} />
                                
                                <div className="mt-2">
                                    <label className="text-[10px] text-gray-400 font-mono block mb-1">Ausrichtung</label>
                                    <div className="flex bg-gray-800 rounded p-1 gap-1">
                                        {['Frontal', 'Boden', 'Seite'].map((label, i) => (
                                            <button 
                                                key={i}
                                                onClick={() => setOrientation(i)}
                                                className={`flex-1 py-1 text-[9px] rounded uppercase font-bold transition-colors ${orientation === i ? 'bg-blue-600 text-white' : 'text-gray-500 hover:text-gray-300'}`}
                                            >
                                                {label}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </ControlGroup>

                            {/* GRID */}
                            <ControlGroup title="Raster (20x20)" icon={Icons.Grid}>
                                <Slider label="Abstand" value={spacing} min={2} max={20} onChange={setSpacing} />
                                <Slider label="Versatz (Reihen)" value={rowOffset} min={-10} max={10} onChange={setRowOffset} />
                            </ControlGroup>

                            {/* BEWEGUNG */}
                            <ControlGroup title="Rhythmus & Chaos" icon={Icons.Move}>
                                <Slider label="Wellen Amplitude" value={waveAmp} min={0} max={20} onChange={setWaveAmp} />
                                <Slider label="Noise (Unruhe Z)" value={noiseAmp} min={0} max={20} onChange={setNoiseAmp} />
                            </ControlGroup>

                            {/* MATERIAL */}
                            <ControlGroup title="Optik (G+D Style)" icon={Icons.Layers}>
                                <ColorPicker label="Hauptfarbe" value={color1} onChange={setColor1} />
                                <ColorPicker label="Glow Farbe" value={color2} onChange={setColor2} />
                                <ColorPicker label="Hintergrund" value={bgColor} onChange={setBgColor} />
                                <div className="mt-2"></div>
                                <Slider label="Transparenz" value={opacity} min={0.1} max={1} step={0.01} onChange={setOpacity} />
                            </ControlGroup>

                            {/* MALEN */}
                            <ControlGroup title="Interaktion" icon={Icons.Brush}>
                                <div className="flex items-center justify-between mb-2">
                                    <span className="text-[10px] text-gray-400">Mal-Modus</span>
                                    <button 
                                        onClick={() => setIsPainting(!isPainting)}
                                        className={`w-10 h-5 rounded-full relative transition-colors ${isPainting ? 'bg-blue-500' : 'bg-gray-700'}`}
                                    >
                                        <div className={`absolute w-3 h-3 bg-white rounded-full top-1 transition-all ${isPainting ? 'left-6' : 'left-1'}`}></div>
                                    </button>
                                </div>
                                {isPainting && (
                                    <div className="space-y-2 animate-in fade-in slide-in-from-top-2 duration-300">
                                        <div className="flex gap-2">
                                            <button onClick={() => setBrushTool(1)} className={`flex-1 py-1 text-[10px] rounded border ${brushTool === 1 ? 'bg-blue-600 border-blue-500 text-white' : 'border-gray-600 text-gray-400'}`}>+ Wachsen</button>
                                            <button onClick={() => setBrushTool(-1)} className={`flex-1 py-1 text-[10px] rounded border ${brushTool === -1 ? 'bg-blue-600 border-blue-500 text-white' : 'border-gray-600 text-gray-400'}`}>- Schrumpfen</button>
                                        </div>
                                        <button onClick={resetMods} className="w-full py-1 text-[10px] text-red-300 bg-red-900/20 border border-red-900/50 rounded hover:bg-red-900/40">Alle zurücksetzen</button>
                                        <p className="text-[9px] text-gray-500 italic text-center pt-1">Klicke oder ziehe die Maus über die Objekte.</p>
                                    </div>
                                )}
                            </ControlGroup>
                        </div>

                        <div className="mt-auto p-4 border-t border-gray-700 bg-gray-900">
                             <button onClick={handleExport} className="w-full bg-white text-black font-bold py-2 rounded flex items-center justify-center gap-2 hover:bg-blue-50 transition-colors">
                                <Icon path={Icons.Download} /> PNG Render Speichern
                             </button>
                        </div>
                    </aside>

                    {/* MAIN CANVAS */}
                    <main className="flex-1 relative bg-black" style={{ background: `radial-gradient(circle at center, #1a2a4a 0%, ${bgColor} 100%)` }}>
                        <Canvas gl={{ preserveDrawingBuffer: true, antialias: true, toneMappingExposure: 1.2 }}>
                            <Scene config={config} paintingState={{ isPainting, modifications, brushTool }} onPaint={handlePaint} />
                        </Canvas>
                        
                        {/* Overlay Info */}
                        <div className="absolute bottom-4 right-4 text-xs font-mono text-white/30 pointer-events-none">
                            Linke Maustaste: Rotieren | Rechte Maustaste: Verschieben | Rad: Zoom
                        </div>
                    </main>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
